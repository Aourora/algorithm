# 排序算法

## 冒泡排序

1. 算法解析
    - 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作

2. 时间复杂度
    - 在数组完全有序的情况下时间复杂度为$O(n)$，数组为倒叙的情况下为$O(n^2)$

3. 空间复杂度
    - 冒泡排序只涉及到相邻数据交换操作，所以空间复杂度为$O(1)$

4. [代码实现](../src/code//%E6%8E%92%E5%BA%8F/bubbleSort/bubbleSort.ts)

5. 特点
    - 稳定、原地

## 插入排序

1. 算法解析
    - 插入排序将数组分为两个区间，有序区间和无序区间，每次从无序区间中取出一个值插入到有序区间中

2. 时间复杂度
    - 在数组完全有序的情况下时间复杂度为$O(n)$，数组为倒叙的情况下为$O(n^2)$

3. 空间复杂度
    - 空间复杂度为$O(1)$

4. [代码实现](../src/code/%E6%8E%92%E5%BA%8F/insertionSort/insertionSort.ts)

5. 特点
    - 稳定、原地

## 选择排序

1. 算法解析
    - 选择排序和插入排序类似，也是将数组分为两个区间，不同的是选择排序每次从无序区间中取出一个极值插入到有序区间中

2. 时间复杂度
    - 最好。、最坏还平均时间复杂度均为$O(n^2)$

3. 空间复杂度
    - 空间复杂度为$O(1)$

4. [代码实现](../src/code//%E6%8E%92%E5%BA%8F/selectionSort//selectionSort.ts)

5. 特点
    - 不稳定、原地

## 希尔排序

1. 算法解析
    - 希尔排序是插入排序的升级版本,通过对数组进行按下标增量分组，每组进行插入排序，直到增量为1

2. 时间复杂度
    - $O(n^(1.3-2))$

3. 空间复杂度
    - 空间复杂度为$O(1)$

4. [代码实现](../src/code//%E6%8E%92%E5%BA%8F/shellSort/shellSort.ts)

5. 特点
    - 不稳定、原地

## 归并排序

1. 算法解析
    - 归并排序使用的是一种分治的思想，将数组分为两组，对每组分别调用归并排序，然后合并两个数组

2. 时间复杂度
    - $O(nlogn)$

3. 空间复杂度
    - 空间复杂度为$O(n)$

4. [代码实现](../src/code//%E6%8E%92%E5%BA%8F/mergeSort/mergeSort.ts)

5. 特点
    - 稳定、非原地

## 快速排序

1. 算法解析
    - 快速排序也是使用一种分治的思想，从数组中选出一个基准值将比基准值大的所有值放在右边，小的放在左边，对两边递归进行快速排序

2. 时间复杂度
    - $O(nlogn)$

3. 空间复杂度
    - 空间复杂度为$O(1)$

4. [代码实现](../src/code//%E6%8E%92%E5%BA%8F/quickSort/quickSort.ts)

5. 特点
    - 不稳定、原地
